require 'rails_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to specify the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator.  If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails.  There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.
#
# Compared to earlier versions of this generator, there is very limited use of
# stubs and message expectations in this spec.  Stubs are only used when there
# is no simpler way to get a handle on the object needed for the example.
# Message expectations are only used when there is no simpler way to specify
# that an instance is receiving a specific message.
#
# Also compared to earlier versions of this generator, there are no longer any
# expectations of assigns and templates rendered. These features have been
# removed from Rails core in Rails 5, but can be added back in via the
# `rails-controller-testing` gem.

RSpec.describe EvaluationsController, type: :controller do

  # This should return the minimal set of values that should be in the session
  # in order to pass any filters (e.g. authentication) defined in
  # EvaluationsController. Be sure to keep this updated too.
  let(:valid_session) { {} }
  let(:filter_session) { { filter: FactoryBot.create(:filter) } }
  let(:filter_group_session) { { filter_group: FactoryBot.create(:filter_group) } }
  let(:filter_attributes) {
    FactoryBot.build(:filter_no_enh).attributes
  }

  context 'Editor is logged in' do
    let(:user) { FactoryBot.create(:editor) }
    before do
      db_sign_in user
    end

    context 'with imported evaluation' do
      let(:eval) { Evaluation.parse(JSON.parse(File.open('spec/support/bad_nginx.json', 'r').read)) }
      describe 'GET #ssp' do
        it 'returns a success response' do
          # evaluation = create :evaluation, created_by: user
          get :ssp, params: { id: eval.to_param }, session: valid_session
          expect(response).to be_success
        end
      end

      describe 'GET #nist' do
        it 'returns a success response' do
          get :nist, params: { format: 'json', id: eval.to_param, category: 'Medium' }, session: valid_session
          expect(response.content_type).to eq('application/json')
        end
      end

      describe 'GET #show with filter' do
        render_views
        it 'returns a success response' do
          get :show, params: { id: eval.to_param }, session: filter_session
          expect(response).to be_success
        end
      end

      describe 'GET #show with filter group' do
        render_views
        it 'returns a success response' do
          filter_group = create :filter_group, created_by: user
          filter = create :filter_simple, created_by: user
          filter_group.filters << filter
          get :show, params: { id: eval.to_param }, session: { filter_group: filter_group }
          expect(response).to be_success
        end
      end

      describe 'GET clear filter' do
        render_views
        it 'returns a success response' do
          get :clear_filter, params: { id: eval.to_param }, session: valid_session
          expect(response).to redirect_to(Evaluation.last)
        end
      end

    end

    describe 'GET #index' do
      it 'returns a success response' do
        create :evaluation, created_by: user
        get :index, params: {}, session: valid_session
        expect(response).to be_success
      end
    end

    describe 'GET #show' do
      render_views
      it 'returns a success response' do
        evaluation = create :evaluation, created_by: user
        get :show, params: { id: evaluation.to_param }, session: valid_session
        expect(response).to be_success
      end
    end

    describe 'POST #upload' do
      it 'can upload an evaluation' do
        @file = fixture_file_upload('sample_jsons/good_nginxresults.json', 'text/json')
        post :upload, params: { file: @file }, session: valid_session
        expect(response).to redirect_to(Evaluation.last)
      end

      it 'rejects a malformed evaluation' do
        @file = fixture_file_upload('spec/support/bad_profile.json', 'text/json')
        post :upload, params: { file: @file }, session: valid_session
        expect(response).to redirect_to(evaluations_path)
      end
    end

    describe 'POST filter' do
      it 'can create a filter' do
        evaluation = create :evaluation, created_by: user
        post :filter, params: { id: evaluation.to_param, filter: filter_attributes }, session: valid_session
        expect(response).to redirect_to(Evaluation.last)
      end

      it 'can save a filter' do
        evaluation = create :evaluation, created_by: user
        post :filter, params: { id: evaluation.to_param, filter: { family: %w{AC SC}, save_filter: 'true' } }, session: valid_session
        expect(response).to redirect_to(Evaluation.last)
      end
    end

    context 'with filters' do
      before(:each) do
        @filter_group = create :filter_group, created_by: user
        @filter = create :filter, filter_group_ids: [@filter_group.id], created_by: user
      end

      describe 'Select filter group' do
        it 'can upload an evaluation' do
          evaluation = create :evaluation, created_by: user
          post :filter_select, params: { id: evaluation.to_param, filter_group: { id: @filter_group.id } }, session: valid_session
          expect(response).to redirect_to(Evaluation.last)
        end
      end

      describe 'Select filter' do
        it 'can upload an evaluation' do
          evaluation = create :evaluation, created_by: user
          post :filter_select, params: { id: evaluation.to_param, filter_group: { id: nil, filter_ids: @filter.id } }, session: valid_session
          expect(response).to redirect_to(Evaluation.last)
        end
      end
    end

    context 'with imported evaluation' do
      let(:eval1) { Evaluation.parse(JSON.parse(File.open('spec/support/ngadev-test1.json', 'r').read)) }
      let(:eval2) { Evaluation.parse(JSON.parse(File.open('spec/support/ngadev-test2.json', 'r').read)) }
      describe 'POST #compare' do
        it 'returns a success response' do
          post :compare, params: { evaluation: { eval_ids: [eval1.to_param, eval2.to_param] } }, session: valid_session
          expect(response).to be_success
        end
      end

      describe 'POST #compare' do
        it 'returns a redirect response' do
          post :compare, params: { evaluation: { eval_ids: [] } }, session: valid_session
          expect(response).to redirect_to(evaluations_path)
        end
      end
    end

    describe 'DELETE #destroy' do
      it 'destroys the owned evaluation' do
        evaluation = create :evaluation, created_by: user
        expect {
          delete :destroy, params: { id: evaluation.to_param }, session: valid_session
        }.to change(Evaluation, :count).by(-1)
      end

      it 'redirects to the evaluation list' do
        evaluation = create :evaluation, created_by: user
        delete :destroy, params: { id: evaluation.to_param }, session: valid_session
        expect(response).to redirect_to(evaluations_url)
      end

    end
  end

  context 'An Admin is logged in' do
    let(:admin) { FactoryBot.create(:admin) }
    before do
      db_sign_in admin
    end

    describe 'DELETE #destroy' do
      it 'destroys the requested evaluation' do
        evaluation = create :evaluation
        expect {
          delete :destroy, params: { id: evaluation.to_param }, session: valid_session
        }.to change(Evaluation, :count).by(-1)
      end
    end

    it 'redirects to the evaluations list' do
      evaluation = create :evaluation
      delete :destroy, params: { id: evaluation.to_param }, session: valid_session
      expect(response).to redirect_to(evaluations_url)
    end
  end

  context 'No one logged in' do
    let(:user) { FactoryBot.create(:editor) }
    let(:ldap_user) { FactoryBot.create(:ldap_editor) }
    describe 'POST #upload_api' do
      it 'can upload an evaluation with an api_key' do
        @file = fixture_file_upload('sample_jsons/good_nginxresults.json', 'text/json')
        expect {
          post :upload_api, params: { file: @file, email: user.email, api_key: user.api_key }, session: valid_session
        }.to change(Evaluation, :count).by(1)
      end

      it 'can upload an evaluation from an ldap user with an api_key' do
        @file = fixture_file_upload('sample_jsons/good_nginxresults.json', 'text/json')
        expect {
          post :upload_api, params: { file: @file, email: ldap_user.email, api_key: ldap_user.api_key }, session: valid_session
        }.to change(Evaluation, :count).by(1)
      end

      it 'cannot upload an evaluation with a bad api_key' do
        @file = fixture_file_upload('sample_jsons/good_nginxresults.json', 'text/json')
        post :upload_api, params: { file: @file, email: user.email, api_key: 'bad_key' }, session: valid_session
        expect(response.body).to eq('ERROR: Could not login User')
      end

      it 'cannot upload a badly formed evaluation' do
        @file = fixture_file_upload('spec/support/bad_profile.json', 'text/json')
        post :upload_api, params: { file: @file, email: user.email, api_key: user.api_key }, session: valid_session
        expect(response.body).to eq('ERROR: Could not upload evaluation')
      end
    end
  end
end
